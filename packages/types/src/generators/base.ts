import type { ComponentCompilerMeta } from '@stencil/core/internal';
import { kebabToPascalCase, normalizeTypeString } from '../utils/string-utils.js';

export interface BaseTypesOptions {
  components: ComponentCompilerMeta[];
  stencilPackageName: string;
  excludeComponents?: string[];
}

export interface ComponentInfo {
  tagName: string;
  pascalName: string;
  propsInterfaceName: string;
  customEventType: string;
  elementType: string;
  properties: PropertyInfo[];
  events: EventInfo[];
}

export interface PropertyInfo {
  name: string;
  type: string;
  docs?: string;
}

export interface EventInfo {
  name: string;
  type: string;
  docs?: string;
}

/**
 * Filters components based on internal flag and exclude list.
 */
export function filterComponents(
  components: ComponentCompilerMeta[],
  excludeComponents?: string[]
): ComponentCompilerMeta[] {
  return components.filter((c) => {
    if (c.internal === true) return false;
    if (excludeComponents?.includes(c.tagName)) return false;
    return true;
  });
}

/**
 * Extracts component information needed for type generation.
 */
export function extractComponentInfo(component: ComponentCompilerMeta): ComponentInfo {
  const tagName = component.tagName;
  const pascalName = kebabToPascalCase(tagName);

  const publicProperties = (component.properties || []).filter((p) => !p.internal);
  const publicEvents = (component.events || []).filter((e) => !e.internal);

  const properties: PropertyInfo[] = publicProperties.map((prop) => ({
    name: prop.name,
    type: normalizeTypeString(prop.complexType?.original || 'any'),
    docs: prop.docs?.text?.trim(),
  }));

  const events: EventInfo[] = publicEvents.map((event) => ({
    name: event.name,
    type: normalizeTypeString(event.complexType?.original || 'void'),
    docs: event.docs?.text?.trim(),
  }));

  return {
    tagName,
    pascalName,
    propsInterfaceName: `${pascalName}NativeProps`,
    customEventType: `${pascalName}CustomEvent`,
    elementType: `HTML${pascalName}Element`,
    properties,
    events,
  };
}

/**
 * Collects all types that need to be imported from the Stencil package.
 */
export function collectImportTypes(
  components: ComponentCompilerMeta[],
  includeCustomEvents: boolean = true
): Set<string> {
  const types = new Set<string>();

  for (const component of components) {
    const pascalName = kebabToPascalCase(component.tagName);
    const publicEvents = (component.events || []).filter((e) => !e.internal);

    if (includeCustomEvents && publicEvents.length > 0) {
      types.add(`${pascalName}CustomEvent`);
    }

    // Collect referenced types from events
    for (const event of publicEvents) {
      if (event.complexType?.references) {
        for (const [refKey, refValue] of Object.entries(event.complexType.references)) {
          if (refValue.location !== 'global') {
            types.add(refKey);
          }
        }
      }
    }

    // Collect referenced types from properties
    const publicProperties = (component.properties || []).filter((p) => !p.internal);
    for (const prop of publicProperties) {
      if (prop.complexType?.references) {
        for (const [refKey, refValue] of Object.entries(prop.complexType.references)) {
          if (refValue.location !== 'global') {
            types.add(refKey);
          }
        }
      }
    }
  }

  return types;
}

/**
 * Generates the standard file header comment.
 */
export function generateHeader(framework: string, stencilPackageName: string, importPath: string): string {
  return `/**
 * This file was automatically generated by the Stencil Types Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * This file provides TypeScript type definitions for using Stencil web components
 * as native custom elements in ${framework}.
 *
 * Usage:
 * Import this file in your application to get type support for custom elements:
 * \`\`\`tsx
 * import '${stencilPackageName}/${importPath}';
 * \`\`\`
 */

/* eslint-disable */
/* tslint:disable */
`;
}
