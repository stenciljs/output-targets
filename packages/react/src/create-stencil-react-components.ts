import type { ComponentCompilerMeta } from '@stencil/core/internal';
import { Project, VariableDeclarationKind } from 'ts-morph';
import { eventListenerName, kebabToPascalCase } from './utils/string-utils.js';
import type { RenderToStringOptions } from './runtime/ssr.js';

interface ReactEvent {
  originalName: string;
  name: string;
  type: string;
}

export const createStencilReactComponents = ({
  components,
  stencilPackageName,
  customElementsDir,
  hydrateModule,
  clientModule,
  serializeShadowRoot,
}: {
  components: ComponentCompilerMeta[];
  stencilPackageName: string;
  customElementsDir: string;
  hydrateModule?: string;
  clientModule?: string;
  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];
}) => {
  const project = new Project({ useInMemoryFileSystem: true });

  /**
   * automatically attach the `use client` directive if we are not generating
   * server side rendering components.
   */
  const useClientDirective = !hydrateModule ? `'use client';\n\n` : '';
  const autogeneratedComment = `/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 */\n\n`;

  const disableEslint = `/* eslint-disable */\n`;
  const createComponentImport = hydrateModule
    ? [
        `// @ts-ignore - ignore potential type issues as the project is importing itself`,
        `import * as clientComponents from '${clientModule}';`,
        '',
        `import { createComponent, type SerializeShadowRootOptions, type HydrateModule, type ReactWebComponent, type DynamicFunction } from '@stencil/react-output-target/ssr';`,
      ].join('\n')
    : `import { createComponent } from '@stencil/react-output-target/runtime';`;
  const sourceFile = project.createSourceFile(
    'component.ts',
    `${useClientDirective}${autogeneratedComment}${disableEslint}
import React from 'react';
${createComponentImport}
import type { EventName, StencilReactComponent } from '@stencil/react-output-target/runtime';
  `
  );

  /**
   * Add the `serializeShadowRoot` variable to the file if the hydrateModule is provided.
   */
  if (hydrateModule) {
    sourceFile.addVariableStatement({
      isExported: true,
      declarationKind: VariableDeclarationKind.Const,
      declarations: [
        {
          name: 'serializeShadowRoot',
          type: 'SerializeShadowRootOptions',
          initializer: serializeShadowRoot
            ? JSON.stringify(serializeShadowRoot)
            : '{ default: "declarative-shadow-dom" }',
        },
      ],
    });
  }

  for (const component of components) {
    const tagName = component.tagName;
    const reactTagName = kebabToPascalCase(tagName);
    const componentElement = `${reactTagName}Element`;
    const componentCustomEvent = `${reactTagName}CustomEvent`;

    sourceFile.addImportDeclaration({
      moduleSpecifier: `${stencilPackageName}/${customElementsDir}/${tagName}.js`,
      namedImports: [
        {
          name: reactTagName,
          alias: componentElement,
        },
        {
          name: 'defineCustomElement',
          alias: `define${reactTagName}`,
        },
      ],
    });

    const publicEvents = (component.events || []).filter((e) => e.internal === false);
    const events: ReactEvent[] = [];
    const importedEventDetailTypes = new Set<string>();
    let importedComponentCustomEvent = false;

    for (const event of publicEvents) {
      /**
       * Import the referenced types from the component library.
       * Stencil will automatically re-export type definitions from the components,
       * if they are used in the component's property or event types.
       */
      if (Object.keys(event.complexType.references).length > 0) {
        for (const referenceKey of Object.keys(event.complexType.references)) {
          const reference = event.complexType.references[referenceKey];
          const isGlobalType = reference.location === 'global';

          /**
           * Global type references should not have an explicit import.
           * The type should be available globally.
           */
          if (!isGlobalType && !importedEventDetailTypes.has(referenceKey)) {
            importedEventDetailTypes.add(referenceKey);
            sourceFile.addImportDeclaration({
              moduleSpecifier: stencilPackageName,
              namedImports: [
                {
                  name: referenceKey,
                  isTypeOnly: true,
                },
              ],
            });
          }
        }
      }

      /**
       * Import the CustomEvent type for the web component from the Stencil package.
       *
       * For example:
       * ```
       * import type { ComponentCustomEvent } from 'my-component-library';
       * ```
       */
      if (!importedComponentCustomEvent) {
        importedComponentCustomEvent = true;
        sourceFile.addImportDeclaration({
          moduleSpecifier: stencilPackageName,
          namedImports: [
            {
              name: componentCustomEvent,
              isTypeOnly: true,
            },
          ],
        });
      }

      // Always type events using the Stencil per-component CustomEvent type.
      events.push({
        originalName: event.name,
        name: eventListenerName(event.name),
        type: `EventName<${componentCustomEvent}<${event.complexType.original}>>`,
      });
    }

    const componentEventNamesType = `${reactTagName}Events`;

    sourceFile.addTypeAlias({
      isExported: true,
      name: componentEventNamesType,
      type: events.length > 0 ? `{ ${events.map((e) => `${e.name}: ${e.type}`).join(',\n')} }` : 'NonNullable<unknown>',
    });

    const clientComponentCall = `/*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({
    tagName: '${tagName}',
    elementClass: ${componentElement},
    // @ts-ignore - ignore potential React type mismatches between the Stencil Output Target and your project.
    react: React,
    events: {${events.map((e) => `${e.name}: '${e.originalName}'`).join(',\n')}} as ${componentEventNamesType},
    defineCustomElement: define${reactTagName}
  })`;

    const serverComponentCall = `/*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({
    tagName: '${tagName}',
    properties: {${component.properties
      /**
       * Filter out properties that don't have an attribute.
       * These are properties with complex types and can't be serialized.
       */
      .filter((prop) => Boolean(prop.attribute))
      .map((e) => `${e.name}: '${e.attribute}'`)
      .join(',\n')}},
    hydrateModule: import('${hydrateModule}') as Promise<HydrateModule>,
    clientModule: clientComponents.${reactTagName} as ReactWebComponent<${componentElement}, ${componentEventNamesType}>,
    serializeShadowRoot,
  })`;

    sourceFile.addVariableStatement({
      isExported: true,
      declarationKind: VariableDeclarationKind.Const,
      // React as never is a hack to by-pass a @types/react issue.
      declarations: [
        {
          name: reactTagName,
          type: `StencilReactComponent<${componentElement}, ${componentEventNamesType}>`,
          initializer: hydrateModule ? serverComponentCall : clientComponentCall,
        },
      ],
    });
  }

  sourceFile.organizeImports();
  sourceFile.formatText();

  return sourceFile.getFullText();
};
