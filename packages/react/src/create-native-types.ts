import type { ComponentCompilerMeta } from '@stencil/core/internal';
import { kebabToPascalCase, normalizeTypeString } from './utils/string-utils.js';

interface NativeTypesOptions {
  components: ComponentCompilerMeta[];
  stencilPackageName: string;
  excludeComponents?: string[];
}

/**
 * Converts an event name to a lowercase React 19 event handler prop name.
 * React 19 lowercases the prop name (minus "on") to get the event name.
 * So for event "myFocus", the handler prop should be "onmyfocus".
 */
const toLowercaseEventHandler = (eventName: string): string => {
  return `on${eventName.toLowerCase()}`;
};

/**
 * Creates a TypeScript declaration file (.d.ts) that provides type definitions
 * for using Stencil web components as native custom elements in React 19+.
 *
 * The generated file augments the `react/jsx-runtime` module to provide proper
 * typing for custom elements when used directly in JSX without wrapper components.
 */
export const createNativeTypes = ({
  components,
  stencilPackageName,
  excludeComponents,
}: NativeTypesOptions): string => {
  // Filter components
  const filteredComponents = components.filter((c) => {
    if (c.internal === true) return false;
    if (excludeComponents?.includes(c.tagName)) return false;
    return true;
  });

  if (filteredComponents.length === 0) {
    return '';
  }

  const lines: string[] = [];

  // Add header comment
  lines.push(`/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * This file provides TypeScript type definitions for using Stencil web components
 * as native custom elements in React 19+.
 *
 * Usage:
 * Import this file in your React application to get type support for custom elements:
 * \`\`\`tsx
 * import '${stencilPackageName}/react-native-types';
 * \`\`\`
 */

/* eslint-disable */
/* tslint:disable */
`);

  // Add the 'import "react"' statement to avoid conflicts with standard HTML elements
  // The @ts-ignore comments prevent errors when this file is processed in a non-React context
  lines.push(`// @ts-ignore - React types may not be available in all build contexts`);
  lines.push(`import 'react';`);
  lines.push(`// @ts-ignore - React types may not be available in all build contexts`);
  lines.push(`import type { DetailedHTMLProps, HTMLAttributes } from 'react';`);

  // Collect all custom event types that need to be imported
  const customEventTypes = new Set<string>();
  const referencedTypes = new Set<string>();

  for (const component of filteredComponents) {
    const reactTagName = kebabToPascalCase(component.tagName);
    const publicEvents = (component.events || []).filter((e) => !e.internal);

    if (publicEvents.length > 0) {
      customEventTypes.add(`${reactTagName}CustomEvent`);
    }

    // Collect referenced types from events
    for (const event of publicEvents) {
      if (event.complexType?.references) {
        for (const [refKey, refValue] of Object.entries(event.complexType.references)) {
          if (refValue.location !== 'global') {
            referencedTypes.add(refKey);
          }
        }
      }
    }

    // Collect referenced types from properties
    const publicProperties = (component.properties || []).filter((p) => !p.internal);
    for (const prop of publicProperties) {
      if (prop.complexType?.references) {
        for (const [refKey, refValue] of Object.entries(prop.complexType.references)) {
          if (refValue.location !== 'global') {
            referencedTypes.add(refKey);
          }
        }
      }
    }
  }

  // Add import for CustomEvent types from the Stencil package
  const allImports = new Set([...customEventTypes, ...referencedTypes]);
  if (allImports.size > 0) {
    lines.push(
      `import type { ${Array.from(allImports).sort().join(', ')} } from '${stencilPackageName}';`
    );
  }

  lines.push('');

  // Generate interface for each component
  for (const component of filteredComponents) {
    const tagName = component.tagName;
    const reactTagName = kebabToPascalCase(tagName);
    const propsInterfaceName = `${reactTagName}NativeProps`;
    const componentCustomEvent = `${reactTagName}CustomEvent`;

    const interfaceProperties: string[] = [];

    // Add properties (skip methods, only include props)
    const publicProperties = (component.properties || []).filter((p) => !p.internal);
    for (const prop of publicProperties) {
      const propType = prop.complexType?.original || 'any';
      const docs = prop.docs?.text ? `  /** ${prop.docs.text.trim()} */\n` : '';
      // Use the prop name (or attribute name if different)
      const propName = prop.name;
      interfaceProperties.push(`${docs}  '${propName}'?: ${normalizeTypeString(propType)};`);
    }

    // Add events with lowercase naming
    const publicEvents = (component.events || []).filter((e) => !e.internal);
    for (const event of publicEvents) {
      const eventType = normalizeTypeString(event.complexType?.original || 'void');
      const docs = event.docs?.text
        ? `  /** Event: ${event.name} - ${event.docs.text.trim()} */\n`
        : `  /** Event: ${event.name} */\n`;
      const handlerName = toLowercaseEventHandler(event.name);
      interfaceProperties.push(
        `${docs}  '${handlerName}'?: (event: ${componentCustomEvent}<${eventType}>) => void;`
      );
    }

    // Generate the props interface
    if (interfaceProperties.length > 0) {
      lines.push(`interface ${propsInterfaceName} {`);
      lines.push(interfaceProperties.join('\n'));
      lines.push(`}`);
    } else {
      lines.push(`interface ${propsInterfaceName} {}`);
    }
    lines.push('');
  }

  // Generate module augmentation for react/jsx-runtime's JSX namespace
  // This is used when tsconfig has "jsx": "react-jsx" (React 17+ automatic runtime)
  lines.push(`declare module 'react/jsx-runtime' {`);
  lines.push(`  namespace JSX {`);
  lines.push(`    interface IntrinsicElements {`);

  for (const component of filteredComponents) {
    const tagName = component.tagName;
    const reactTagName = kebabToPascalCase(tagName);
    const propsInterfaceName = `${reactTagName}NativeProps`;
    const elementType = `HTML${reactTagName}Element`;

    lines.push(
      `      '${tagName}': DetailedHTMLProps<HTMLAttributes<${elementType}> & ${propsInterfaceName}, ${elementType}>;`
    );
  }

  lines.push(`    }`);
  lines.push(`  }`);
  lines.push(`}`);
  lines.push('');

  return lines.join('\n');
};
