import { describe, it, expect } from 'vitest';
import { dedent } from 'ts-dedent';
import type { ComponentCompilerMeta } from '@stencil/core/internal';

import { createStencilReactComponents } from './create-stencil-react-components.js';

describe('createStencilReactComponents', () => {
  it('should generate a basic react component without events', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`'use client';`);
    expect(result).toContain(`This file was automatically generated by the Stencil React Output Target.`);
    expect(result).toContain(`/* eslint-disable */`);
    expect(result).toContain(`import React from 'react';`);
    expect(result).toContain(`import { createComponent } from '@stencil/react-output-target/runtime';`);
    expect(result).toContain(`import type { StencilReactComponent } from '@stencil/react-output-target/runtime';`);
    expect(result).toContain(
      `import { MyComponent as MyComponentElement, defineCustomElement as defineMyComponent } from "my-package/dist/custom-elements/my-component.js";`
    );
    expect(result).toContain(`export type MyComponentEvents = NonNullable<unknown>;`);
    expect(result)
      .toContain(`export const MyComponent: StencilReactComponent<MyComponentElement, MyComponentEvents> = /*@__PURE__*/ createComponent<MyComponentElement, MyComponentEvents>({
    tagName: 'my-component',
    elementClass: MyComponentElement,
    // @ts-ignore - ignore potential React type mismatches between the Stencil Output Target and your project.
    react: React,
    events: {} as MyComponentEvents,
    defineCustomElement: defineMyComponent
});`);
  });

  it('should generate a react component with events', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-button',
        componentClassName: 'MyButton',
        properties: [],
        events: [
          {
            name: 'myClick',
            internal: false,
            complexType: {
              original: 'void',
              resolved: 'void',
              references: {},
            },
          },
          {
            name: 'myHover',
            internal: false,
            complexType: {
              original: 'string',
              resolved: 'string',
              references: {},
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/components',
    });

    expect(result).toContain(`import { type MyButtonCustomEvent } from "my-package";`);
    expect(result).toContain(`onMyClick: EventName<MyButtonCustomEvent<void>>`);
    expect(result).toContain(`onMyHover: EventName<MyButtonCustomEvent<string>>`);
    expect(result).toContain(`onMyClick: 'myClick'`);
    expect(result).toContain(`onMyHover: 'myHover'`);
  });

  it('should filter out internal events', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [
          {
            name: 'publicEvent',
            internal: false,
            complexType: {
              original: 'void',
              resolved: 'void',
              references: {},
            },
          },
          {
            name: 'internalEvent',
            internal: true,
            complexType: {
              original: 'void',
              resolved: 'void',
              references: {},
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`onPublicEvent: EventName<MyComponentCustomEvent<void>>`);
    expect(result).not.toContain('internalEvent');
    expect(result).not.toContain('onInternalEvent');
  });

  it('should import event detail types from references', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [
          {
            name: 'myEvent',
            internal: false,
            complexType: {
              original: 'MyEventDetail',
              resolved: '{ value: string; }',
              references: {
                MyEventDetail: {
                  location: 'import',
                  path: './types',
                  id: 'src/types.ts::MyEventDetail',
                },
              },
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`type MyEventDetail`);
    expect(result).toContain(`EventName<MyComponentCustomEvent<MyEventDetail>>`);
  });

  it('should not import global type references', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [
          {
            name: 'myEvent',
            internal: false,
            complexType: {
              original: 'Event',
              resolved: 'Event',
              references: {
                Event: {
                  location: 'global',
                  path: '',
                  id: '',
                },
              },
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).not.toContain(`import { type Event }`);
    expect(result).toContain(`EventName<MyComponentCustomEvent<Event>>`);
  });

  it('should handle multiple components', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-button',
        componentClassName: 'MyButton',
        properties: [],
        events: [],
      } as any,
      {
        tagName: 'my-input',
        componentClassName: 'MyInput',
        properties: [],
        events: [],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`MyButton`);
    expect(result).toContain(`MyInput`);
    expect(result).toContain(`my-button`);
    expect(result).toContain(`my-input`);
    expect(result).toContain(`defineMyButton`);
    expect(result).toContain(`defineMyInput`);
  });

  it('should generate server-side rendering components when hydrateModule is provided', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [
          {
            name: 'value',
            attribute: 'value',
          },
          {
            name: 'complexProp',
          },
        ],
        events: [],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      hydrateModule: 'my-package/hydrate',
      clientModule: './client',
    });

    expect(result).not.toContain(`'use client';`);
    expect(result).toContain(`// @ts-ignore - ignore potential type issues as the project is importing itself`);
    expect(result).toContain(`import * as clientComponents from './client';`);
    expect(result).toContain(`from '@stencil/react-output-target/ssr'`);
    expect(result).toContain(`type HydrateModule`);
    expect(result).toContain(`type ReactWebComponent`);
    expect(result).toContain(`type SerializeShadowRootOptions`);
    expect(result).toContain(
      `export const serializeShadowRoot: SerializeShadowRootOptions = { default: "declarative-shadow-dom" };`
    );
    expect(result).toContain(`tagName: 'my-component',
    properties: { value: 'value' },
    hydrateModule: import('my-package/hydrate') as Promise<HydrateModule>,
    clientModule: clientComponents.MyComponent as ReactWebComponent<MyComponentElement, MyComponentEvents>,
    serializeShadowRoot,`);
  });

  it('should filter out properties without attributes for SSR', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [
          {
            name: 'simpleProp',
            attribute: 'simple-prop',
          },
          {
            name: 'complexProp',
          },
          {
            name: 'anotherSimple',
            attribute: 'another-simple',
          },
        ],
        events: [],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      hydrateModule: 'my-package/hydrate',
      clientModule: './client',
    });

    expect(result).toContain(`simpleProp: 'simple-prop'`);
    expect(result).toContain(`anotherSimple: 'another-simple'`);
    expect(result).not.toContain('complexProp');
  });

  it('should use custom serializeShadowRoot options when provided', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      hydrateModule: 'my-package/hydrate',
      clientModule: './client',
      serializeShadowRoot: { default: 'scoped' },
    });

    expect(result).toContain(`export const serializeShadowRoot: SerializeShadowRootOptions = { "default": "scoped" };`);
  });

  it('should handle kebab-case to PascalCase conversion', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-custom-button',
        componentClassName: 'MyCustomButton',
        properties: [],
        events: [],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`MyCustomButton`);
    expect(result).toContain(`MyCustomButtonElement`);
    expect(result).toContain(`MyCustomButtonEvents`);
    expect(result).toContain(`defineMyCustomButton`);
  });

  it('should not duplicate imported event detail types', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [
          {
            name: 'eventOne',
            internal: false,
            complexType: {
              original: 'SharedType',
              resolved: '{ value: string; }',
              references: {
                SharedType: {
                  location: 'import',
                  path: './types',
                  id: 'src/types.ts::SharedType',
                },
              },
            },
          },
          {
            name: 'eventTwo',
            internal: false,
            complexType: {
              original: 'SharedType',
              resolved: '{ value: string; }',
              references: {
                SharedType: {
                  location: 'import',
                  path: './types',
                  id: 'src/types.ts::SharedType',
                },
              },
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    const sharedTypeImports = result.match(/type SharedType/g);
    expect(sharedTypeImports).not.toBeNull();
    expect(sharedTypeImports!.length).toBe(1);
  });

  it('should handle events with multiple type references', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [
          {
            name: 'complexEvent',
            internal: false,
            complexType: {
              original: '{ typeA: TypeA; typeB: TypeB; }',
              resolved: '{ typeA: TypeA; typeB: TypeB; }',
              references: {
                TypeA: {
                  location: 'import',
                  path: './types',
                  id: 'src/types.ts::TypeA',
                },
                TypeB: {
                  location: 'import',
                  path: './types',
                  id: 'src/types.ts::TypeB',
                },
              },
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`type TypeA`);
    expect(result).toContain(`type TypeB`);
  });

  it('should handle components with no events', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: undefined,
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    expect(result).toContain(`export type MyComponentEvents = NonNullable<unknown>;`);
    expect(result).toContain(`events: {} as MyComponentEvents,`);
  });

  it('should organize and format imports correctly', () => {
    const components: ComponentCompilerMeta[] = [
      {
        tagName: 'my-component',
        componentClassName: 'MyComponent',
        properties: [],
        events: [
          {
            name: 'myEvent',
            internal: false,
            complexType: {
              original: 'void',
              resolved: 'void',
              references: {},
            },
          },
        ],
      } as any,
    ];

    const result = createStencilReactComponents({
      components,
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
    });

    const lines = result.split('\n');
    const reactImportIndex = lines.findIndex((line) => line.includes(`import React from 'react';`));
    const createComponentImportIndex = lines.findIndex((line) => line.includes(`import { createComponent }`));
    const customElementImportIndex = lines.findIndex((line) =>
      line.includes(`import { MyComponent as MyComponentElement`)
    );

    expect(reactImportIndex).toBeGreaterThan(-1);
    expect(createComponentImportIndex).toBeGreaterThan(-1);
    expect(customElementImportIndex).toBeGreaterThan(-1);
  });
});
